{
  "name": "Sat-js",
  "tagline": "A simple JavaScript library for performing 2D collision detection",
  "body": "SAT.js\r\n======\r\n\r\n - [Classes](#classes)\r\n - [Collision Tests](#collision-tests)\r\n - [Examples](#examples)\r\n\r\nAbout\r\n-----\r\n\r\nSAT.js is a simple JavaScript library for performing collision detection (and projection-based collision response) of simple 2D shapes.  It uses the [Separating Axis Theorem](http://en.wikipedia.org/wiki/Hyperplane_separation_theorem) (hence the name)\r\n\r\nIt supports detecting collisions between:\r\n - Circles (using Voronoi Regions.)\r\n - Convex Polygons (and simple Axis-Aligned Boxes, which are of course, convex polygons.)\r\n\r\nIt also supports checking whether a point is inside a circle or polygon.\r\n\r\nIt's released under the [MIT](http://en.wikipedia.org/wiki/MIT_License) license.\r\n\r\nCurrent version: `0.6.0`. [Annotated source code](http://jriecken.github.io/sat-js/docs/SAT.html) is available.\r\n\r\nNicely compresses with the [Google Closure Compiler](https://developers.google.com/closure/compiler/) in **Advanced** mode to about 6KB (2KB gzipped)\r\n\r\nTo use it in node.js, you can run `npm install sat` and then use it with `var SAT = require('sat');`\r\n\r\n<a name=\"classes\"></a>\r\nClasses\r\n--------\r\n\r\nSAT.js contains the following JavaScript classes:\r\n\r\n### SAT.Vector (aliased as SAT.V)\r\n\r\nThis is a simple 2D vector/point class.  It is created by calling:\r\n```javascript\r\n// Create the vector (10,10) - If (x,y) not specified, defaults to (0,0).\r\nvar v = new SAT.Vector(10, 10)\r\n```\r\n\r\nIt has the following properties:\r\n\r\n - `x` - The x-coordinate of the Vector.\r\n - `y` - The y-coordinate of the Vector.\r\n\r\nIt contains the following methods:\r\n\r\n - `copy(other)` - Copy the value of another Vector to this one.\r\n - `clone()` - Return a new vector with the same coordinates as this one.\r\n - `perp()` - Change this vector to be perpendicular to what it was before.\r\n - `rotate(angle)` - Rotate this vector counter-clockwise by the specified number of radians.\r\n - `reverse()` - Reverse this Vector.\r\n - `normalize()` - Make the Vector unit-lengthed.\r\n - `add(other)` - Add another Vector to this one.\r\n - `sub(other)` - Subtract another Vector from this one.\r\n - `scale(x,y)` - Scale this Vector in the X and Y directions.\r\n - `project(other)` - Project this Vector onto another one.\r\n - `projectN(other)` - Project this Vector onto a unit Vector.\r\n - `reflect(axis)` - Reflect this Vector on an arbitrary axis Vector.\r\n - `reflectN(axis)` - Reflect this Vector on an arbitrary axis unit Vector.\r\n - `dot(other)` - Get the dot product of this Vector and another.\r\n - `len2()` - Get the length squared of this Vector.\r\n - `len()` - Get the length of this Vector\r\n\r\n### SAT.Circle\r\n\r\nThis is a simple circle with a center position and a radius.  It is created by calling:\r\n```javascript\r\n// Create a circle whose center is (10,10) with radius of 20\r\nvar c = new SAT.Circle(new SAT.Vector(10,10), 20);\r\n```\r\n\r\nIt has the following properties:\r\n\r\n - `pos` - A Vector representing the center of the circle.\r\n - `r` - The radius of the circle\r\n\r\n\r\n### SAT.Polygon\r\n\r\nThis is a **convex** polygon, whose points are specified in a counter-clockwise fashion.  It is created by calling:\r\n```javascript\r\n// Create a triangle at (0,0)\r\nvar p = new SAT.Polygon(new SAT.Vector(), [\r\n  new SAT.Vector(),\r\n  new SAT.Vector(100,0),\r\n  new SAT.Vector(50,75)\r\n]);\r\n```\r\n\r\nNote: The points are counter-clockwise *with respect to the coordinate system*. If you directly draw the points on a screen that has the origin at the top-left corner it will _appear_ visually that the points are being specified clockwise. This is just because of the inversion of the Y-axis when being displayed.\r\n\r\nYou can create a line segment by creating a `Polygon` that contains only 2 ppoints.\r\n\r\nIt has the following properties:\r\n\r\n - `pos` - The position of the polygon (all points are relative to this).\r\n - `points` - Array of vectors representing the original points of the polygon.\r\n - `angle` - Angle to rotate the polgon (affects `calcPoints`)\r\n - `offset` - Translation to apply to the polygon before the `angle` rotation (affects `calcPoints`)\r\n - `calcPoints` - (Calculated) The collision polygon - effectively `points` with `angle` and `offset` applied.\r\n - `edges` - (Calculated) Array of Vectors representing the edges of the calculated polygon\r\n - `normals` - (Calculated) Array of Vectors representing the edge normals of the calculated polygon (perpendiculars)\r\n\r\nYou should _not_ manually change any of the properties except `pos` - use the `setPoints`, `setAngle`, and `setOffset` methods to ensure that the calculated properties are updated correctly.\r\n\r\nIt has the following methods:\r\n\r\n - `setPoints(points)` - Set the original points\r\n - `setAngle(angle)` - Set the current rotation angle (in radians)\r\n - `setOffset(offset)` - Set the current offset\r\n - `rotate(angle)` - Rotate the original points of this polygon counter-clockwise (around its local coordinate system) by the specified number of radians. The `angle` rotation will be applied on top of this rotation.\r\n - `translate(x, y)` - Translate the original points of this polygon (relative to the local coordinate system) by the specified amounts. The `offset` translation will be applied on top of this translation.\r\n\r\n### SAT.Box\r\n\r\nThis is a simple Box with a position, width, and height.  It is created by calling:\r\n```javascript\r\n// Create a box at (10,10) with width 20 and height 40.\r\nvar b = new SAT.Box(new SAT.Vector(10,10), 20, 40);\r\n```\r\n\r\nIt has the following properties:\r\n\r\n - `pos` - The bottom-left coordinate of the box (i.e the smallest `x` value and the smallest `y` value).\r\n - `w` - The width of the box.\r\n - `h` - The height of the box.\r\n\r\nIt has the following methods:\r\n\r\n - `toPolygon()` - Returns a new Polygon whose edges are the edges of the box.\r\n\r\n### SAT.Response\r\n\r\nThis is the object representing the result of a collision between two objects.  It just has a simple `new Response()` constructor.\r\n\r\nIt has the following properties:\r\n\r\n - `a` - The first object in the collision.\r\n - `b` - The second object in the collison.\r\n - `overlap` - Magnitude of the overlap on the shortest colliding axis.\r\n - `overlapN` - The shortest colliding axis (unit-vector)\r\n - `overlapV` - The overlap vector (i.e. `overlapN.scale(overlap, overlap)`).  If this vector is subtracted from the position of `a`, `a` and `b` will no longer be colliding.\r\n - `aInB` - Whether the first object is completely inside the second.\r\n - `bInA` - Whether the second object is completely inside the first.\r\n\r\nIt has the following methods:\r\n\r\n- `clear()` - Clear the response so that it is ready to be reused for another collision test.\r\n\r\n\r\n<a name=\"tests\"></a>\r\nCollision Tests\r\n---------------\r\n\r\nSAT.js contains the following collision tests:\r\n\r\n### `SAT.pointInCircle(p, c)`\r\n\r\nChecks whether a given point is inside the specified circle.\r\n\r\n### `SAT.pointInPolygon(p, poly)`\r\n\r\nChecks whether a given point is inside a specified convex polygon.\r\n\r\n### `SAT.testCircleCircle(a, b, response)`\r\n\r\nTests for a collision between two `Circle`s, `a`, and `b`.  If a response is to be calculated in the event of collision, pass in a cleared `Response` object.\r\n\r\nReturns `true` if the circles collide, `false` otherwise.\r\n\r\n### `SAT.testPolygonCircle(polygon, circle, response)`\r\n\r\nTests for a collision between a `Polygon` and a `Circle`.  If a response is to be calculated in the event of a collision, pass in a cleared `Response` object.\r\n\r\nReturns `true` if there is a collision, `false` otherwise.\r\n\r\n### `SAT.testCirclePolygon(circle, polygon, response)`\r\n\r\nThe same thing as `SAT.testPolygonCircle`, but in the other direction.\r\n\r\nReturns `true` if there is a collision, `false` otherwise.\r\n\r\n*NOTE: This is slightly slower than `SAT.testPolygonCircle` as it just calls that and reverses the result*\r\n\r\n### `SAT.testPolygonPolygon(a, b, response)`\r\n\r\nTests whether two polygons `a` and `b` collide. If a response is to be calculated in the event of collision, pass in a cleared `Response` object.\r\n\r\nReturns `true` if there is a collision, `false` otherwise.\r\n\r\n*NOTE: If you want to detect a collision between `Box`es, use the `toPolygon()` method*\r\n\r\n<a name=\"examples\"></a>\r\nExamples\r\n--------\r\n\r\nTest two circles\r\n```javascript\r\nvar V = SAT.Vector;\r\nvar C = SAT.Circle;\r\n\r\nvar circle1 = new C(new V(0,0), 20);\r\nvar circle2 = new C(new V(30,0), 20);\r\nvar response = new SAT.Response();\r\nvar collided = SAT.testCircleCircle(circle1, circle2, response);\r\n\r\n// collided => true\r\n// response.overlap => 10\r\n// response.overlapV => (10, 0)\r\n```\r\n\r\nTest a circle and a polygon\r\n```javascript\r\nvar V = SAT.Vector;\r\nvar C = SAT.Circle;\r\nvar P = SAT.Polygon;\r\n\r\nvar circle = new C(new V(50,50), 20);\r\n// A square\r\nvar polygon = new P(new V(0,0), [\r\n  new V(0,0), new V(40,0), new V(40,40), new V(0,40)\r\n]);\r\nvar response = new SAT.Response();\r\nvar collided = SAT.testPolygonCircle(polygon, circle, response);\r\n\r\n// collided => true\r\n// response.overlap ~> 5.86\r\n// response.overlapV ~> (4.14, 4.14) - i.e. on a diagonal\r\n```\r\n\r\nTest two polygons\r\n```javascript\r\nvar V = SAT.Vector;\r\nvar P = SAT.Polygon;\r\n\r\n// A square\r\nvar polygon1 = new P(new V(0,0), [\r\n  new V(0,0), new V(40,0), new V(40,40), new V(0,40)\r\n]);\r\n// A triangle\r\nvar polygon2 = new P(new V(30,0), [\r\n  new V(0,0), new V(30, 0), new V(0, 30)\r\n]);\r\nvar response = new SAT.Response();\r\nvar collided = SAT.testPolygonPolygon(polygon1, polygon2, response);\r\n\r\n// collided => true\r\n// response.overlap => 10\r\n// response.overlapV => (10, 0)\r\n```\r\n\r\nNo collision between two Boxes\r\n```javascript\r\nvar V = SAT.Vector;\r\nvar B = SAT.Box;\r\n\r\nvar box1 = new B(new V(0,0), 20, 20).toPolygon();\r\nvar box2 = new B(new V(100,100), 20, 20).toPolygon();\r\nvar collided = SAT.testPolygonPolygon(box1, box2);\r\n\r\n// collided => false\r\n```\r\n\r\nHit testing a circle and polygon\r\n```javascript\r\nvar V = SAT.Vector;\r\nvar C = SAT.Circle;\r\nvar P = SAT.Polygon;\r\n\r\nvar triangle = new P(new V(30,0), [\r\n  new V(0,0), new V(30, 0), new V(0, 30)\r\n]);\r\nvar circle = new C(new V(100,100), 20);\r\n\r\nSAT.pointInPolygon(new V(0,0), triangle); // false\r\nSAT.pointInPolygon(new V(35, 5), triangle); // true\r\nSAT.pointInCircle(new V(0,0), circle); // false\r\nSAT.pointInCircle(new V(110,110), circle); // true\r\n\r\n```\r\n\r\nTests\r\n-----\r\n\r\nTo run the tests from your console:\r\n\r\n```\r\nmocha\r\n```\r\n\r\nTo install `mocha` you will need to have run `npm install` after cloning the repo.\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}